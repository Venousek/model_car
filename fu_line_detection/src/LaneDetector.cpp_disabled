/*
 * LaneDetector.cpp
 *
 *  Created on: 16.12.2014
 *      Author: conrad
 */

#include "modules/cognition/vision/LaneDetector.h"

#include "debug.h"
#include <cmath>
#include "modules/cognition/cognition.h"

#define PI 3.14159265

REGISTER_MODULE(Cognition, LaneDetector, true,
        "Models the lane markings as polynomial of 2rd degree");

namespace {
    auto cfgSection = ConfigRegistry::getSection(
        "cognition.vision.lanedetector");

    auto cfgDefaultLeft = cfgSection->registerOption<double>("defaultyleft",
            0.63, "Default y value of left lane marking");
    auto cfgDefaultCenter = cfgSection->registerOption<double>("defaultycenter",
            0.21, "Default y value of center lane marking");
    auto cfgDefaultRight = cfgSection->registerOption<double>("defaultyright",
            -0.21, "Default y value of right lane marking");

    auto cfgMinXRoi = cfgSection->registerOption<double>("minxroi",
            0.05, "Min x value of rois");

    auto cfgMaxXDefaultRoi = cfgSection->registerOption<double>(
            "maxxdefaultroi", 0.75, "Max x value of the default rois");
    auto cfgMaxXPolyRoi = cfgSection->registerOption<double>(
            "maxxpolyroi", 0.9,  "Max x value of the polynomial rois");

    auto cfgPolyRoiWidth = cfgSection->registerOption<double>(
            "polyroiwidth", 0.1, "Width of roi arround polynomials");
    auto cfgDefaultRoiWidth = cfgSection->registerOption<double>(
            "defaultroiwidth", 0.3,  "Width of the default rois");

    auto cfgMaxDistance = cfgSection->registerOption<double>("maxdistance",
            0.01, "Max distance points to polys to be considered supporters");

    auto cfgIterRansac = cfgSection->registerOption<int>("iterransac",
            10,  "Number of RANSAC iterations");

    auto cfgThreshould = cfgSection->registerOption<double>("threshould", 0.7,
            "Threshould of proportion of ransac supporters to all data points");


}

namespace {
    auto dbgPolyLeft = REGISTER_DEBUG(
            "cognition.vision.lanedetection.polyleft", DRAWING_RELATIVE,
            "draw the left lane marking poly");
    auto dbgPolyCenter = REGISTER_DEBUG(
            "cognition.vision.lanedetection.polycenter", DRAWING_RELATIVE,
            "draw the center lane marking poly");
    auto dbgPolyRight = REGISTER_DEBUG(
            "cognition.vision.lanedetection.polyright", DRAWING_RELATIVE,
            "draw the right lane marking poly");

    auto dbgRoiLeft = REGISTER_DEBUG(
            "cognition.vision.lanedetection.roileft", DRAWING_RELATIVE,
            "draw the roi arround the left poly");
    auto dbgRoiCenter = REGISTER_DEBUG(
            "cognition.vision.lanedetection.roicenter", DRAWING_RELATIVE,
            "draw the roi arround the center poly");
    auto dbgRoiRight = REGISTER_DEBUG(
            "cognition.vision.lanedetection.roiright", DRAWING_RELATIVE,
            "draw the roi arround the right poly");

    auto dbgDefaultLines = REGISTER_DEBUG(
            "cognition.vision.lanedetection.defaultlines", DRAWING_RELATIVE,
            "draw the default lines");
    auto dbgDefaultRois = REGISTER_DEBUG(
            "cognition.vision.lanedetection.defaultrois", DRAWING_RELATIVE,
            "draw the default rois arround the lines");

    auto dbgSupportersLeft = REGISTER_DEBUG(
            "cognition.vision.lanedetection.supportersleft", DRAWING_RELATIVE,
            "draw the supporters of the left poly");
    auto dbgSupportersCenter = REGISTER_DEBUG(
            "cognition.vision.lanedetection.supporterscenter", DRAWING_RELATIVE,
            "draw the supporters of the center poly");
    auto dbgSupportersRight = REGISTER_DEBUG(
            "cognition.vision.lanedetection.supportersright", DRAWING_RELATIVE,
            "draw the supporters of the right poly");

    auto dbgLaneMarkingsLeft = REGISTER_DEBUG(
            "cognition.vision.lanedetection.lanemarkingsleft", DRAWING_RELATIVE,
            "draw the lane markings of the left roi");
    auto dbgLaneMarkingsCenter = REGISTER_DEBUG(
            "cognition.vision.lanedetection.lanemarkingscenter", DRAWING_RELATIVE,
            "draw the lane markings of the center roi");
    auto dbgLaneMarkingsRight = REGISTER_DEBUG(
            "cognition.vision.lanedetection.lanemarkingsright", DRAWING_RELATIVE,
            "draw the lane markings of the right roi");

    auto dbgPointsLeft = REGISTER_DEBUG(
            "cognition.vision.lanedetection.pointsleft", DRAWING_RELATIVE,
            "draw the data points of the left poly");
    auto dbgPointsCenter = REGISTER_DEBUG(
            "cognition.vision.lanedetection.pointscenter", DRAWING_RELATIVE,
            "draw the data points of the center poly");
    auto dbgPointsRight = REGISTER_DEBUG(
            "cognition.vision.lanedetection.pointsright", DRAWING_RELATIVE,
            "draw the data points of the right poly");

    auto dbgLanePoly = REGISTER_DEBUG(
            "cognition.vision.lanedetection.lanepoly", DRAWING_RELATIVE,
            "draw the poly of the right lane center");

    auto dbgProportions = REGISTER_DEBUG(
            "cognition.vision.lanedetection.proportions", DRAWING_RELATIVE,
            "write the proportions of the polys into the relative");


    auto dbgMessages = REGISTER_DEBUG(
            "cognition.vision.lanedetection.debugmessages", TEXT,
            "write debug messages");

    auto dbgValues = REGISTER_DEBUG(
            "cognition.vision.lanedetection.debugvalues", TEXT,
            "write debug values");
}

void LaneDetector::init() /* override*/{
}

void LaneDetector::execute() /*override*/{
    // set variables to config values
    defaultYLeft   = cfgDefaultLeft->get() * meters;
    defaultYCenter = cfgDefaultCenter->get() * meters;
    defaultYRight  = cfgDefaultRight->get() * meters;

    minXRoi        = cfgMinXRoi->get() * meters;
    maxXDefaultRoi = cfgMaxXDefaultRoi->get() * meters;
    maxXPolyRoi    = cfgMaxXPolyRoi->get() * meters;

    interestDistancePoly = (cfgPolyRoiWidth->get() / 2) * meters;
    interestDistanceDefault = (cfgDefaultRoiWidth->get() / 2) * meters;

    iterationsRansac = cfgIterRansac->get();
    proportionThreshould = cfgThreshould->get();

    maxDistance    = cfgMaxDistance->get() * meters;

    // clear some stuff from the last cycle
    bestPolyLeft = std::make_pair(NewtonPolynomial(), 0);
    bestPolyCenter = std::make_pair(NewtonPolynomial(), 0);
    bestPolyRight = std::make_pair(NewtonPolynomial(), 0);

    supportersLeft.clear();
    supportersCenter.clear();
    supportersRight.clear();

    // start actual execution
    buildLaneMarkingsLists(getLaneMarkings().get());

    ransac();

    detectLane(0.7);

    // Debugging

    // debug default lines and rois
    drawDefaultLines(dbgDefaultLines, 0, 255, 255);
    drawDefaultRois(dbgDefaultRois, 0, 170, 170);

    // lane markings found in current used rois
    drawLaneMarkings(dbgLaneMarkingsLeft, laneMarkingsLeft, 0, 100, 100);
    drawLaneMarkings(dbgLaneMarkingsCenter, laneMarkingsCenter, 100, 100, 0);
    drawLaneMarkings(dbgLaneMarkingsRight, laneMarkingsRight, 100, 0, 0);

    // debug polys and poly rois
    if (polyDetectedLeft) {
        drawPoly(dbgPolyLeft, polyLeft, 0, 255, 255);
        drawPolyRoi(dbgRoiLeft, polyLeft, 0, 200, 200);
        drawSupporters(dbgSupportersLeft, supportersLeft, 200, 255, 255);
        drawPoints(dbgPointsLeft, pointsLeft, 0, 50, 50);
    }

    if (polyDetectedCenter) {
        drawPoly(dbgPolyCenter, polyCenter, 255, 255, 0);
        drawPolyRoi(dbgRoiCenter, polyCenter, 200, 200, 0);
        drawSupporters(dbgSupportersCenter, supportersCenter, 255, 255, 200);
        drawPoints(dbgPointsCenter, pointsCenter, 50, 50, 0);
    }

    if (polyDetectedRight) {
        drawPoly(dbgPolyRight, polyRight, 255, 0, 0);
        drawPolyRoi(dbgRoiRight, polyRight, 200, 0, 0);
        drawSupporters(dbgSupportersRight, supportersRight, 255, 200, 200);
        drawPoints(dbgPointsRight, pointsRight, 50, 0, 0);
    }

    writeProportions();

    if (lanePoly.getDegree() != -1) {
        drawPoly(dbgLanePoly, lanePoly, 255, 255, 255);
    }
}

/**
 * Creates three vectors of lane marking points out of the given lane marking
 * point vector.
 *
 * A point has to lie within the ROI of the previously detected lane polynomial
 * or within the default ROI, if no polynomial was detected.
 * The lists are the input data for the RANSAC algorithm.
 *
 * @param laneMarkings  a vector containing all detected lane markings
 */
void LaneDetector::buildLaneMarkingsLists(
        const std::vector<Point<Meter>> &laneMarkings) {
    laneMarkingsLeft.clear();
    laneMarkingsCenter.clear();
    laneMarkingsRight.clear();

    for (Point<Meter> laneMarking : laneMarkings) {
        if (polyDetectedLeft) {
            if (isInPolyRoi(polyLeft, laneMarking)) {
                laneMarkingsLeft.push_back(laneMarking);
                continue;
            }
        }

        if (polyDetectedCenter) {
            if (isInPolyRoi(polyCenter, laneMarking)) {
                laneMarkingsCenter.push_back(laneMarking);
                continue;
            }
        }

        if (polyDetectedRight) {
            if (isInPolyRoi(polyRight, laneMarking)) {
                laneMarkingsRight.push_back(laneMarking);
                continue;
            }
        }

        if (isInDefaultRoi(LEFT, laneMarking)) {
            laneMarkingsLeft.push_back(laneMarking);
            continue;
        }

        if (isInDefaultRoi(CENTER, laneMarking)) {
            laneMarkingsCenter.push_back(laneMarking);
            continue;
        }

        if (isInDefaultRoi(RIGHT, laneMarking)) {
            laneMarkingsRight.push_back(laneMarking);
            continue;
        }
    }
}

/**
 * Calculates the horizontal distance between a point and the default line given
 * by its position.
 *
 * @param line  The position of the default line (LEFT, CENTER or RIGHT)
 * @param p     The given point
 * @return      The horizontal distance between default line and point
 */
Meter LaneDetector::horizDistanceToDefaultLine(ePosition &line, Point<Meter> &p) {
    double pY = p.getY().value();
    double distance = 0;

    switch (line) {
    case LEFT:
        distance = std::abs(pY - defaultYLeft.value());
        break;
    case CENTER:
        distance = std::abs(pY - defaultYCenter.value());
        break;
    case RIGHT:
        distance = std::abs(pY - defaultYRight.value());
        break;
    }

    return distance * meters;
}

/**
 * Calculates the horizontal distance between a point and a polynomial.
 *
 * @param poly  The given polynomial
 * @param p     The given point
 * @return      The horizontal distance between the polynomial and the point
 */
Meter LaneDetector::horizDistanceToPolynomial(NewtonPolynomial& poly,
        Point<Meter> &p) {
    double pY = p.getY().value();
    double pX = p.getX().value();

    double polyY = poly.at(pX);
    double distance = std::abs(pY - polyY);

    return distance * meters;
}

/**
 * Calculates the horizontal distance between two points.
 *
 * @param p1    The first point
 * @param p2    The second point
 * @return      The horizontal distance between the two points
 */
Meter LaneDetector::horizDistance(Point<Meter> &p1, Point<Meter> &p2) {
    double y1 = p1.getY().value();
    double y2 = p2.getY().value();

    return std::abs(y1 - y2) * meters;
}

/**
 * Calculates the gradient of a polynomial at a given x value. The used formula
 * was obtained by the following steps:
 * - start with the polynomial of 2nd degree in newton basis form:
 *   p(x) = c0 + c1(x - x0) + c2(x - x0)(x - x1)
 * - expand the equation and sort it by descending powers of x
 * - form the first derivative
 *
 * Applying the given x value then results in the wanted gradient.
 *
 * @param x         The given x value
 * @param points    The data points used for interpolating the polynomial
 * @param coeffs    The coefficients under usage of the newton basis
 * @return          The gradient of the polynomial at x
 */
double LaneDetector::gradient(double x, std::vector<Point<Meter>> &points,
        std::vector<double> coeffs) {
    return 2 * coeffs[2] * x + coeffs[1] - coeffs[2] * points[1].getX().value()
            - coeffs[2] * points[0].getX().value();
}

/**
 * Calculates the x value of the point where the normal of the tangent of a
 * polynomial at a given point p intersects with a second polynomial.
 *
 * The formula for the intersection point is obtained by setting equal the
 * following two formula:
 *
 * 1. the formula of the normal in point-slope-form:
 *     y - p_y = -(1 / m) * (x - p_x) which is the same as
 *           y = -(x / m) + (p_x / m) + p_y
 *
 * 2. the formula of the second polynomial of 2nd degree in newton basis form:
 *           y = c0 + c1(x - x0) + c2(x - x0)(x - x1)
 *
 * Expanding everything and moving it to the right side gives a quadratic
 * equation in the general form of 0 = ax^2 + bx + c, which can be solved using
 * the general quadratic formula x = (-b +- sqrt(b^2 - 4ac)) / 2a
 *
 * The three cases for the discriminant are taken into account.
 *
 * @param p         The point of the first poly at which its tangent is used
 * @param m         The gradient of the tangent
 * @param points    The data points used for interpolating the second polynomial
 * @param coeffs    The coeffs of the second polynomial with newton basis
 * @return          The x value of the intersection point of normal and 2nd poly
 */
double LaneDetector::intersection(Point<double> &p, double &m,
        std::vector<Point<Meter>> &points, std::vector<double> &coeffs) {
    double a = coeffs[2];
    double b = coeffs[1] - (coeffs[2] * points[1].getX().value())
            - (coeffs[2] * points[0].getX().value()) + (1.0 / m);
    double c = coeffs[0] - (coeffs[1] * points[0].getX().value())
            + (coeffs[2] * points[0].getX().value() * points[1].getX().value())
            - p.getY() - (p.getX() / m);

    double dis = std::pow(b, 2) - (4 * a * c);
    double x1 = 0;
    double x2 = 0;

    if (dis < 0) {
        return -1;
    }
    else if (dis == 0) {
        return -b / (2 * a);
    }
    else {
        x1 = (-b + std::sqrt(std::pow(b, 2) - (4 * a * c))) / (2 * a);
        x2 = (-b - std::sqrt(std::pow(b, 2) - (4 * a * c))) / (2 * a);
    }

    return fmax(x1, x2);
}

/**
 * Calculates the gradient of a second polynomial at the point, at which the
 * normal of the tangent of the first polynomial at the given point
 * intersects with the second polynomial.
 *
 * @param x         The given x value of the point on the first polynomial
 * @param poly1     The first polynomial
 * @param points1   The data points used for interpolating the first poly
 * @param points2   The data points used for interpolating the second poly
 * @param coeffs1   The coeffs of the first poly using newton basis
 * @param coeffs2   The coeffs of the second poly using newton basis
 * @param m1        The gradient of the first poly at x
 * @return          The gradient of the second poly at the intersection point
 */
double LaneDetector::nextGradient(double x, NewtonPolynomial &poly1,
        std::vector<Point<Meter>> &points1, std::vector<Point<Meter>> &points2,
        std::vector<double> coeffs1, std::vector<double> coeffs2, double m1) {

    Point<double> p = Point<double>(x, poly1.at(x));
    double x2 = intersection(p, m1, points2, coeffs2);

    return gradient(x2, points2, coeffs2);
}

/**
 * Check two gradients for similarity. Return true if the difference in degree
 * is less than 10.
 *
 * @param m1    The first gradient
 * @param m2    The second gradient
 * @return      True, if the diffenence between the gradients is less than 10°
 */
bool LaneDetector::gradientsSimilar(double &m1, double &m2) {
    double a1 = atan(m1) * 180 / PI;
    double a2 = atan(m2) * 180 / PI;

    if (abs(a1 - a2) < 10) {
        return true;
    }
    else {
        return false;
    }
}

/**
 * Finds the position of the polynomial with the highest proportion.
 * @return The position of the best polynomial
 */
ePosition LaneDetector::maxProportion() {
    ePosition maxPos = LEFT;
    double maxVal = bestPolyLeft.second;

    if (bestPolyCenter.second > maxVal) {
        maxPos = CENTER;
        maxVal = bestPolyCenter.second;
    }

    if (bestPolyRight.second > maxVal) {
        maxPos = RIGHT;
    }

    return maxPos;
}

/**
 * Create the lane polynomial starting from the detected polynomial of the
 * given position. A lane polynomial is formed by shifting points with
 * different x-values of the used polynomial along the normals of the polynomial
 * at this points to the distance, where the respective lane polynomial is
 * expected to lie.
 *
 * @param position  The position of the detected polynomial used as reference
 */
void LaneDetector::createLanePoly(ePosition position) {
    lanePoly.clear();

    double x1 = 0.05;
    double x2 = 0.4;
    double x3 = 1.0;

    Point<double> pointRight1;
    Point<double> pointRight2;
    Point<double> pointRight3;

    Point<double> pointLeft1;
    Point<double> pointLeft2;
    Point<double> pointLeft3;

    double m1 = 0;
    double m2 = 0;
    double m3 = 0;

    double dRight = 0;

    NewtonPolynomial usedPoly;

    /*
     * Depending on the sign of the gradient of the poly at the different
     * x-values and depending on which position we are, we have to add or
     * subtract the expected distance to the respective lane polynomial, to get
     * the wanted points.
     *
     * The calculation is done for the x- and y-components of the points
     * separately using the trigonometric ratios of right triangles and the fact
     * that arctan of some gradient equals its angle to the x-axis in degree.
     */
    if (position == LEFT) {
        usedPoly = polyLeft;
        m1 = gradient(x1, pointsLeft, usedPoly.getCoefficients());
        m2 = gradient(x2, pointsLeft, usedPoly.getCoefficients());
        m3 = gradient(x3, pointsLeft, usedPoly.getCoefficients());

        dRight = defaultYLeft.value();

        if (m1 > 0) {
            pointRight1 = Point<double>(x1 + dRight * cos(atan(-1 / m1)),
                    usedPoly.at(x1) + dRight * sin(atan(-1 / m1)));
        }
        else {
            pointRight1 = Point<double>(x1 - dRight * cos(atan(-1 / m1)),
                    usedPoly.at(x1) - dRight * sin(atan(-1 / m1)));
        }

        if (m2 > 0) {
            pointRight2 = Point<double>(x2 + dRight * cos(atan(-1 / m2)),
                    usedPoly.at(x2) + dRight * sin(atan(-1 / m2)));
        }
        else {
            pointRight2 = Point<double>(x2 - dRight * cos(atan(-1 / m2)),
                    usedPoly.at(x2) - dRight * sin(atan(-1 / m2)));
        }

        if (m3 > 0) {
            pointRight3 = Point<double>(x3 + dRight * cos(atan(-1 / m3)),
                    usedPoly.at(x3) + dRight * sin(atan(-1 / m3)));
        }
        else {
            pointRight3 = Point<double>(x3 - dRight * cos(atan(-1 / m3)),
                    usedPoly.at(x3) - dRight * sin(atan(-1 / m3)));
        }
    }
    else if (position == CENTER) {
        usedPoly = polyCenter;
        m1 = gradient(x1, pointsCenter, usedPoly.getCoefficients());
        m2 = gradient(x2, pointsCenter, usedPoly.getCoefficients());
        m3 = gradient(x3, pointsCenter, usedPoly.getCoefficients());

        dRight = defaultYCenter.value();

        if (m1 > 0) {
            pointRight1 = Point<double>(x1 + dRight * cos(atan(-1 / m1)),
                    usedPoly.at(x1) + dRight * sin(atan(-1 / m1)));
        }
        else {
            pointRight1 = Point<double>(x1 - dRight * cos(atan(-1 / m1)),
                    usedPoly.at(x1) - dRight * sin(atan(-1 / m1)));
        }

        if (m2 > 0) {
            pointRight2 = Point<double>(x2 + dRight * cos(atan(-1 / m2)),
                    usedPoly.at(x2) + dRight * sin(atan(-1 / m2)));
        }
        else {
            pointRight2 = Point<double>(x2 - dRight * cos(atan(-1 / m2)),
                    usedPoly.at(x2) - dRight * sin(atan(-1 / m2)));
        }

        if (m3 > 0) {
            pointRight3 = Point<double>(x3 + dRight * cos(atan(-1 / m3)),
                    usedPoly.at(x3) + dRight * sin(atan(-1 / m3)));
        }
        else {
            pointRight3 = Point<double>(x3 - dRight * cos(atan(-1 / m3)),
                    usedPoly.at(x3) - dRight * sin(atan(-1 / m3)));
        }
    }
    else if (position == RIGHT) {
        usedPoly = polyRight;
        m1 = gradient(x1, pointsRight, usedPoly.getCoefficients());
        m2 = gradient(x2, pointsRight, usedPoly.getCoefficients());
        m3 = gradient(x3, pointsRight, usedPoly.getCoefficients());

        dRight = defaultYCenter.value();

        if (m1 > 0) {
            pointRight1 = Point<double>(x1 - dRight * cos(atan(-1 / m1)),
                    usedPoly.at(x1) - dRight * sin(atan(-1 / m1)));
        }
        else {
            pointRight1 = Point<double>(x1 + dRight * cos(atan(-1 / m1)),
                    usedPoly.at(x1) + dRight * sin(atan(-1 / m1)));
        }

        if (m2 > 0) {
            pointRight2 = Point<double>(x2 - dRight * cos(atan(-1 / m2)),
                    usedPoly.at(x2) - dRight * sin(atan(-1 / m2)));
        }
        else {
            pointRight2 = Point<double>(x2 + dRight * cos(atan(-1 / m2)),
                    usedPoly.at(x2) + dRight * sin(atan(-1 / m2)));
        }

        if (m3 > 0) {
            pointRight3 = Point<double>(x3 - dRight * cos(atan(-1 / m3)),
                    usedPoly.at(x3) - dRight * sin(atan(-1 / m3)));
        }
        else {
            pointRight3 = Point<double>(x3 + dRight * cos(atan(-1 / m3)),
                    usedPoly.at(x3) + dRight * sin(atan(-1 / m3)));
        }
    }

    // create the lane polynomial out of the shifted points
    lanePoly.addData(pointRight1);
    lanePoly.addData(pointRight2);
    lanePoly.addData(pointRight3);

    getLanePolynomial().setLanePoly(lanePoly);
    getLanePolynomial().setDetected();
}

/**
 * Decide, which of the detected polynomials (if there are any) should be used
 * as reference for creating the lane polynomials.
 *
 * @param startX    The x-value, starting from which we compare the detected polys
 */
void LaneDetector::detectLane(double startX) {
    if (polyDetectedLeft && !polyDetectedCenter && !polyDetectedRight) {
        createLanePoly(LEFT);
    }
    else if (!polyDetectedLeft && polyDetectedCenter && !polyDetectedRight) {
        createLanePoly(CENTER);
    }
    else if (!polyDetectedLeft && !polyDetectedCenter && polyDetectedRight) {
        createLanePoly(RIGHT);
    }
    else if (polyDetectedLeft && polyDetectedCenter && !polyDetectedRight) {
        double gradLeft = gradient(startX, pointsLeft,
                polyLeft.getCoefficients());

        double gradCenter = nextGradient(startX, polyLeft, pointsLeft,
                pointsCenter, polyLeft.getCoefficients(),
                polyCenter.getCoefficients(), gradLeft);

        if (gradientsSimilar(gradLeft, gradCenter)) {
            createLanePoly(LEFT);
        }
        else {
            if (bestPolyLeft.second >= bestPolyCenter.second) {
                createLanePoly(LEFT);
            }
            else {
                createLanePoly(CENTER);
            }
        }
    }
    else if (!polyDetectedLeft && polyDetectedCenter && polyDetectedRight) {
        double gradCenter = gradient(startX, pointsCenter,
                polyCenter.getCoefficients());

        double gradRight = nextGradient(startX, polyCenter, pointsCenter,
                pointsRight, polyCenter.getCoefficients(),
                polyRight.getCoefficients(), gradCenter);

        if (gradientsSimilar(gradCenter, gradRight)) {
            createLanePoly(RIGHT);
        }
        else {
            if (bestPolyCenter.second >= bestPolyRight.second) {
                createLanePoly(CENTER);
            }
            else {
                createLanePoly(RIGHT);
            }
        }
    }
    else if (polyDetectedLeft && !polyDetectedCenter && polyDetectedRight) {
        double gradLeft = gradient(startX, pointsLeft,
                polyLeft.getCoefficients());

        double gradRight = nextGradient(startX, polyLeft, pointsLeft,
                pointsRight, polyLeft.getCoefficients(),
                polyRight.getCoefficients(), gradLeft);

        if (gradientsSimilar(gradLeft, gradRight)) {
            createLanePoly(LEFT);
        }
        else {
            if (bestPolyLeft.second >= bestPolyRight.second) {
                createLanePoly(LEFT);
            }
            else {
                createLanePoly(RIGHT);
            }
        }
    }
    else if (polyDetectedLeft && polyDetectedCenter && polyDetectedRight) {
        double gradLeft = gradient(startX, pointsLeft,
                polyLeft.getCoefficients());

        double gradCenter2 = gradient(startX, pointsCenter,
                polyCenter.getCoefficients());

        double gradCenter1 = nextGradient(startX, polyLeft, pointsLeft,
                pointsCenter, polyLeft.getCoefficients(),
                polyCenter.getCoefficients(), gradLeft);

        double gradRight1 = nextGradient(startX, polyLeft, pointsLeft,
                pointsRight, polyLeft.getCoefficients(),
                polyRight.getCoefficients(), gradLeft);

        double gradRight2 = nextGradient(startX, polyCenter, pointsCenter,
                pointsRight, polyCenter.getCoefficients(),
                polyRight.getCoefficients(), gradCenter2);

        if (gradientsSimilar(gradLeft, gradCenter1)) {
            if (gradientsSimilar(gradCenter1, gradRight1)) {
                createLanePoly(LEFT);
            }
            else {
                createLanePoly(LEFT);
            }
        }
        else {
            if (gradientsSimilar(gradCenter2, gradRight2)) {
                createLanePoly(RIGHT);
            }
            else {
                ePosition maxPos = maxProportion();
                if (maxPos == LEFT) {
                    createLanePoly(LEFT);
                }
                else if (maxPos == CENTER) {
                    createLanePoly(CENTER);
                }
                else if (maxPos == RIGHT) {
                    createLanePoly(RIGHT);
                }
            }
        }
    }
    else if (!polyDetectedLeft && !polyDetectedCenter && !polyDetectedRight) {
        lanePoly.clear();

        getLanePolynomial().setNotDetected();
    }
}

/**
 * Starts the RANSAC algorithm for detecting each of the three lane marking
 * polynomials.
 */
void LaneDetector::ransac() {
    polyDetectedLeft = ransacInternal(LEFT, laneMarkingsLeft, bestPolyLeft,
            polyLeft, supportersLeft, prevPolyLeft, pointsLeft);

    polyDetectedCenter = ransacInternal(CENTER, laneMarkingsCenter,
            bestPolyCenter, polyCenter, supportersCenter, prevPolyCenter,
            pointsCenter);

    polyDetectedRight = ransacInternal(RIGHT, laneMarkingsRight, bestPolyRight,
            polyRight, supportersRight, prevPolyRight, pointsRight);
}

/**
 * Detects a polynomial with RANSAC in a given list of lane marking edge points.
 *
 * @param position      The position of the wanted polynomial
 * @param laneMarkings  A reference to the list of lane marking edge points
 * @param bestPoly      A reference to a pair containing the present best
 *                      detected polynomial and a value representing the fitting
 *                      quality called proportion
 * @param poly          A reference to the polynomial that gets detected
 * @param supporters    A reference to the supporter points of the present best
 *                      polynomial
 * @param prevPoly      A reference to the previous polynomial detected at this
 *                      position
 * @param points        A reference to the points selected for interpolating the
 *                      present best polynomial
 * @return              true if a polynomial could be detected and false when not
 */
bool LaneDetector::ransacInternal(ePosition position,
        std::vector<Point<Meter>>& laneMarkings,
        std::pair<NewtonPolynomial, double>& bestPoly, NewtonPolynomial& poly,
        std::vector<Point<Meter>>& supporters, NewtonPolynomial& prevPoly,
        std::vector<Point<Meter>>& points) {

    if (laneMarkings.size() < 7) {
        return false;
    }

    int iterations = 0;

    // sort the lane marking edge points
    std::vector<Point<Meter>> sortedMarkings = laneMarkings;

    std::sort(sortedMarkings.begin(), sortedMarkings.end(),
            [](Point<Meter> a, Point<Meter> b) {
                return a.getX().value() < b.getX().value();
            });

    std::vector<Point<Meter>> tmpSupporters = std::vector<Point<Meter>>();

    // vectors for points selected from the bottom, mid and top of the sorted
    // point vector
    std::vector<Point<Meter>> markings1 = std::vector<Point<Meter>>();
    std::vector<Point<Meter>> markings2 = std::vector<Point<Meter>>();
    std::vector<Point<Meter>> markings3 = std::vector<Point<Meter>>();

    bool highEnoughX = false;

    // Points are selected from the bottom, mid and top. The selection regions
    // are spread apart for better results during RANSAC
    for (std::vector<Point<Meter>>::size_type i = 0; i != sortedMarkings.size();
            i++) {
        if (i < double(sortedMarkings.size()) / 7) {
            markings1.push_back(sortedMarkings[i]);
        }
        else if (i >= (double(sortedMarkings.size()) / 7) * 3
                && i < (double(sortedMarkings.size()) / 7) * 4) {
            markings2.push_back(sortedMarkings[i]);
        }
        else if (i >= (double(sortedMarkings.size()) / 7) * 6) {
            markings3.push_back(sortedMarkings[i]);
        }

        if (sortedMarkings[i].getX().value() > 0.5) {
            highEnoughX = true;
        }
    }

    if (position == CENTER) {
        if (!highEnoughX) {
            prevPoly = poly;
            poly.clear();
            return false;
        }
    }

    // save the polynomial from the previous picture
    prevPoly = poly;

    while (iterations < iterationsRansac) {
        iterations++;

        // randomly select 3 different lane marking points from bottom, mid and
        // top
        int pos1 = rand() % markings1.size();
        int pos2 = rand() % markings2.size();
        int pos3 = rand() % markings3.size();

        Point<Meter> p1 = markings1[pos1];
        Point<Meter> p2 = markings2[pos2];
        Point<Meter> p3 = markings3[pos3];

        double p1X = p1.getX().value();
        double p1Y = p1.getY().value();
        double p2X = p2.getX().value();
        double p2Y = p2.getY().value();
        double p3X = p3.getX().value();
        double p3Y = p3.getY().value();

        // clear poly for reuse
        poly.clear();

        // create a polynomial with the selected points
        poly.addData(p1X, p1Y);
        poly.addData(p2X, p2Y);
        poly.addData(p3X, p3Y);

        // check if this polynomial is not useful
        if (!polyValid(position, poly, prevPoly)) {
            poly.clear();
            continue;
        }

        // count the supporters and save them for debugging
        int count1 = 0;
        int count2 = 0;
        int count3 = 0;

        // find the supporters
        tmpSupporters.clear();

        for (Point<Meter> p : markings1) {
            if (horizDistanceToPolynomial(poly, p) <= maxDistance) {
                count1++;
                tmpSupporters.push_back(p);
            }
        }

        for (Point<Meter> p : markings2) {
            if (horizDistanceToPolynomial(poly, p) <= maxDistance) {
                count2++;
                tmpSupporters.push_back(p);
            }
        }

        for (Point<Meter> p : markings3) {
            if (horizDistanceToPolynomial(poly, p) <= maxDistance) {
                count3++;
                tmpSupporters.push_back(p);
            }
        }

        if (count1 == 0 || count2 == 0 || count3 == 0) {
            poly.clear();
            DEBUG_TEXT(dbgMessages,
                    "Poly had no supporters in one of the regions")
            continue;
        }

        // calculate the proportion of supporters of all lane markings
        double proportion = (double(count1) / markings1.size()
                + double(count2) / markings2.size()
                + 3 * (double(count3) / markings3.size())) / 5;

        if (proportion < proportionThreshould) {
            poly.clear();
            DEBUG_TEXT(dbgMessages,
                    "Poly proportion was smaller than threshold");
            continue;
        }

        // check if poly is better than bestPoly
        if (proportion > bestPoly.second) {
            bestPoly = std::make_pair(poly, proportion);
            supporters = tmpSupporters;

            points.clear();
            points.push_back(p1);
            points.push_back(p2);
            points.push_back(p3);
        }
    }

    poly = bestPoly.first;

    if (poly.getDegree() == -1) {
        return false;
    }

    DEBUG_TEXT(dbgValues, "best poly proportion: %f", bestPoly.second);

    return true;
}

/**
 * Method for drawing the default lines in furemote
 */
void LaneDetector::drawDefaultLines(
        std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>> debugTarget,
        int r, int g, int b) {
    // left line
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            LINE(Centimeter(minXRoi), Centimeter(defaultYLeft),
                    Centimeter(maxXDefaultRoi), Centimeter(defaultYLeft));
    });

    // center line
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            LINE(Centimeter(minXRoi), Centimeter(defaultYCenter),
                    Centimeter(maxXDefaultRoi), Centimeter(defaultYCenter));
    });

    // right line
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            LINE(Centimeter(minXRoi), Centimeter(defaultYRight),
                    Centimeter(maxXDefaultRoi), Centimeter(defaultYRight));
    });
}

/**
 * Method for drawing the ROIs around the default lines
 */
void LaneDetector::drawDefaultRois(
        std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>> debugTarget,
        int r, int g, int b) {
    // left roi
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            LINE(Centimeter(minXRoi),
                    Centimeter(defaultYLeft - interestDistanceDefault),
                    Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYLeft - interestDistanceDefault));
            LINE(Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYLeft - interestDistanceDefault),
                    Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYLeft + interestDistanceDefault));
            LINE(Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYLeft + interestDistanceDefault),
                    Centimeter(minXRoi),
                    Centimeter(defaultYLeft + interestDistanceDefault));
            LINE(Centimeter(minXRoi),
                    Centimeter(defaultYLeft + interestDistanceDefault),
                    Centimeter(minXRoi),
                    Centimeter(defaultYLeft - interestDistanceDefault));
    });

    // center roi
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            LINE(Centimeter(minXRoi),
                    Centimeter(defaultYCenter - interestDistanceDefault),
                    Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYCenter - interestDistanceDefault));
            LINE(Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYCenter - interestDistanceDefault),
                    Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYCenter + interestDistanceDefault));
            LINE(Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYCenter + interestDistanceDefault),
                    Centimeter(minXRoi),
                    Centimeter(defaultYCenter + interestDistanceDefault));
            LINE(Centimeter(minXRoi),
                    Centimeter(defaultYCenter + interestDistanceDefault),
                    Centimeter(minXRoi),
                    Centimeter(defaultYCenter - interestDistanceDefault));
    });

    // right roi
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            LINE(Centimeter(minXRoi),
                    Centimeter(defaultYRight - interestDistanceDefault),
                    Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYRight - interestDistanceDefault));
            LINE(Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYRight - interestDistanceDefault),
                    Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYRight + interestDistanceDefault));
            LINE(Centimeter(maxXDefaultRoi),
                    Centimeter(defaultYRight + interestDistanceDefault),
                    Centimeter(minXRoi),
                    Centimeter(defaultYRight + interestDistanceDefault));
            LINE(Centimeter(minXRoi),
                    Centimeter(defaultYRight + interestDistanceDefault),
                    Centimeter(minXRoi),
                    Centimeter(defaultYRight - interestDistanceDefault));
    });
}

/**
 * Method for drawing a detected polynomial
 */
void LaneDetector::drawPoly(
        std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>> debugTarget,
        NewtonPolynomial& poly, int r, int g, int b) {
    std::vector<double> xCoordinates = produceXCoordinates(maxXPolyRoi);
    std::vector<double> polyYCoordinates = getPolyYCoordinates(xCoordinates,
            poly);

    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            for (unsigned int i = 0; i < xCoordinates.size(); i++) {
                CIRCLE(Centimeter(xCoordinates[i] * meters),
                        Centimeter(polyYCoordinates[i] * meters),
                        1 * centimeters);
            }
    });
}

/**
 * Method for drawing the ROI around a detected polynomial
 */
void LaneDetector::drawPolyRoi(
        std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>> debugTarget,
        NewtonPolynomial& poly, int r, int g, int b) {
    std::vector<double> xCoordinates = produceXCoordinates(maxXPolyRoi);
    std::vector<double> polyYCoordinates = getPolyYCoordinates(xCoordinates,
            poly);

    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            for (unsigned int i = 0; i < xCoordinates.size(); i++) {
                CIRCLE(Centimeter(xCoordinates[i] * meters),
                        Centimeter((polyYCoordinates[i]
                                - interestDistancePoly.value()) * meters),
                                1 * centimeters);
                CIRCLE(Centimeter(xCoordinates[i] * meters),
                        Centimeter((polyYCoordinates[i]
                                + interestDistancePoly.value()) * meters),
                                1 * centimeters);
            }
    });

}

void LaneDetector::writeProportions() {
    DRAWDEBUG(dbgProportions, {
            SETCOLORWHITE;
            TEXT(-10 * centimeters, Centimeter(defaultYLeft),
                    std::to_string(bestPolyLeft.second));
            TEXT(-10 * centimeters, Centimeter(defaultYCenter),
                    std::to_string(bestPolyCenter.second));
            TEXT(-10 * centimeters, Centimeter(defaultYRight),
                    std::to_string(bestPolyRight.second));
    });
}

/**
 * Calculates a vector of y-values of the given polynomial at the x-values given
 * as vector. The "at"-method of the NewtonPolynomial class is used, which
 * relies on the horner scheme.
 *
 * @param xCoordinates  The vector of x-values
 * @param poly          The given polynomial
 * @return              The vector of calculated y-values.
 */
std::vector<double> LaneDetector::getPolyYCoordinates(
        std::vector<double> xCoordinates, NewtonPolynomial& poly) {
    std::vector<double> yCoordinates;
    double yValue;

    for (double xValue : xCoordinates) {
        yValue = poly.at(xValue);
        yCoordinates.push_back(yValue);
    }

    return yCoordinates;
}

/**
 * Create a vector of ascending x-values starting with the minimal x-value of
 * the ROIs and ending with the x-value distance. The x-values are 0.05 apart.
 *
 * @param distance  x-values smaller than this are added
 * @return          The vector of x-values
 */
std::vector<double> LaneDetector::produceXCoordinates(Meter distance) {
    std::vector<double> xCoordinates;
    double x = minXRoi.value();

    while (x < distance.value()) {
        xCoordinates.push_back(x);
        x += 0.05;
    }

    return xCoordinates;
}

/**
 * Method for drawing the supporters of a detected polynomial
 */
void LaneDetector::drawSupporters(
        std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>> debugTarget,
        std::vector<Point<Meter>> supporters, int r, int g, int b) {
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            for (Point<Meter> p : supporters) {
                CIRCLE(Centimeter(p.getX()), Centimeter(p.getY()),
                        0.5 * centimeters);
            }
    });
}

/**
 * Method for drawing the lane marking points used to detect a polynomial
 */
void LaneDetector::drawLaneMarkings(
        std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>> debugTarget,
        std::vector<Point<Meter>> laneMarkings, int r, int g, int b) {
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            for (Point<Meter> p : laneMarkings) {
                CIRCLE(Centimeter(p.getX()), Centimeter(p.getY()),
                        2 * centimeters);
            }
    });
}

/**
 * Method for drawing the points selected to interpolate the polynomial
 */
void LaneDetector::drawPoints(
        std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>> debugTarget,
        std::vector<Point<Meter>> points, int r, int g, int b) {
    DRAWDEBUG(debugTarget, {
            SETCOLOR(r, g, b);
            for (Point<Meter> p : points) {
                CIRCLE(Centimeter(p.getX()), Centimeter(p.getY()),
                        2.5 * centimeters);
            }
    });
}

/**
 * Method, that checks, if a polynomial produced during RANSAC counts as usable.
 *
 * @param position  The position of the polynomial, that is checked
 * @param poly      The polynomial, that is checked
 * @param prevPoly  The previous polynomial detected at this position
 * @return          True, if the polynomial counts as valid
 */
bool LaneDetector::polyValid(ePosition position, NewtonPolynomial poly,
        NewtonPolynomial prevPoly) {

    Point<Meter> p1 = Point<Meter>(0.3 * meters, poly.at(0.3) * meters);

    if (horizDistanceToDefaultLine(position, p1) > 0.5 * meters) {
        DEBUG_TEXT(dbgMessages,
                "Poly was to far away from default line at x = 0.3");
        return false;
    }

    Point<Meter> p2 = Point<Meter>(0.6 * meters, poly.at(0.6) * meters);

    if (horizDistanceToDefaultLine(position, p2) > 0.8 * meters) {
        DEBUG_TEXT(dbgMessages,
                "Poly was to far away from default line at x = 0.6");
        return false;
    }

    Point<Meter> p3 = Point<Meter>(1.0 * meters, poly.at(1.0) * meters);

    if (horizDistanceToDefaultLine(position, p3) > 1.0 * meters) {
        DEBUG_TEXT(dbgMessages,
                "Poly was to far away from default line at x = 1.0");
        return false;
    }

    if (prevPoly.getDegree() != -1) {
        Point<Meter> p4 = Point<Meter>(0.5 * meters, poly.at(0.5) * meters);
        Point<Meter> p5 = Point<Meter>(0.5 * meters, prevPoly.at(0.5) * meters);

        if (horizDistance(p4, p5) > 0.05 * meters) {
            DEBUG_TEXT(dbgMessages,
                    "Poly was to far away from previous poly at x = 0.5");
            return false;
        }

        Point<Meter> p6 = Point<Meter>(0.3 * meters, poly.at(0.3) * meters);
        Point<Meter> p7 = Point<Meter>(0.3 * meters, prevPoly.at(0.3) * meters);

        if (horizDistance(p6, p7) > 0.05 * meters) {
            DEBUG_TEXT(dbgMessages,
                    "Poly was to far away from previous poly at 0.3");
            return false;
        }
    }

    return true;
}

/**
 * Method, that checks if a point lies within the default ROI of a position.
 *
 * @param position  The position of the default ROI
 * @param p         The given point, which is checked
 * @return          True, if the point lies within the default ROI
 */
bool LaneDetector::isInDefaultRoi(ePosition position, Point<Meter> &p) {
    if (p.getX() < minXRoi || p.getX() > maxXDefaultRoi) {
        return false;
    }
    else if (horizDistanceToDefaultLine(position, p)
            <= interestDistanceDefault) {
        return true;
    }
    else {
        return false;
    }
}

/**
 * Method, that checks if a point lies within the the ROI of a polynomial.
 *
 * @param poly      The polynomial, whose ROI is used
 * @param p         The point, which is checked
 * @return          True, if the point lies within the polynomial's ROI
 */
bool LaneDetector::isInPolyRoi(NewtonPolynomial &poly, Point<Meter> &p) {
    if (p.getX() < minXRoi || p.getX() > maxXPolyRoi) {
        return false;
    }
    else if (horizDistanceToPolynomial(poly, p) <= interestDistancePoly) {
        return true;
    }
    else {
        return false;
    }
}

