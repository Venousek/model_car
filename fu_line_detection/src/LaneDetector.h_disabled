/*
 * LaneDetector.h
 *
 *  Created on: 16.12.2014
 *      Author: conrad
 */

#ifndef SRC_MODULES_COGNITION_VISION_LANEDETECTOR_H_
#define SRC_MODULES_COGNITION_VISION_LANEDETECTOR_H_

#include "representations/cognition/vision/LanePolynomial.h"
#include "ModuleFramework/Module.h"
#include "representations/cognition/vision/LaneMarkings.h"
#include "tools/interpolation/NewtonPolynomial.h"
#include "tools/geometry/Path.h"

/*----------------------------------------------------------------------------*/

BEGIN_DECLARE_MODULE(LaneDetector)
    REQUIRE(LaneMarkings)
    PROVIDE(LanePolynomial)
END_DECLARE_MODULE(LaneDetector)

/*----------------------------------------------------------------------------*/

/**
 * An enum type for distinguishing between the positions of the lane markings
 */
enum ePosition {
    LEFT,  //!< position of things associated with the left lane marking
    CENTER,//!< position of things associated with the center lane marking
    RIGHT  //!< position of things associated with the right lane marking
};

/**
 * A class that uses RANSAC to detect polynomials in the lane marking points,
 * which then are used to produce a driving path.
 */
class LaneDetector: public LaneDetectorBase {
public:
    LaneDetector() {
        polyDetectedLeft     = false;
        polyDetectedCenter   = false;
        polyDetectedRight    = false;

        bestPolyLeft         = std::make_pair(NewtonPolynomial(), 0);
        bestPolyCenter       = std::make_pair(NewtonPolynomial(), 0);
        bestPolyRight        = std::make_pair(NewtonPolynomial(), 0);

        laneMarkingsLeft     = std::vector<Point<Meter>>();
        laneMarkingsCenter   = std::vector<Point<Meter>>();
        laneMarkingsRight    = std::vector<Point<Meter>>();

        polyLeft             = NewtonPolynomial();
        polyCenter           = NewtonPolynomial();
        polyRight            = NewtonPolynomial();

        supportersLeft       = std::vector<Point<Meter>>();
        supportersCenter     = std::vector<Point<Meter>>();
        supportersRight      = std::vector<Point<Meter>>();

        prevPolyLeft         = NewtonPolynomial();
        prevPolyCenter       = NewtonPolynomial();
        prevPolyRight        = NewtonPolynomial();

        pointsLeft           = std::vector<Point<Meter>>();
        pointsCenter         = std::vector<Point<Meter>>();
        pointsRight          = std::vector<Point<Meter>>();

        lanePoly             = NewtonPolynomial();

        iterationsRansac     = 0;
        proportionThreshould = 0;
    }

    virtual ~LaneDetector() = default;

    virtual void init() override;
    virtual void execute() override;

private:
    /**
     * Horizontal relative positions of the default lane marking lines.
     *
     * These lines are situated in a position, where the lane markings of a
     * straight lane would show up in the relative coordinate system with the
     * car standing in the center of the right lane.
     */
    Meter defaultYLeft;
    Meter defaultYCenter;
    Meter defaultYRight;

    /**
     * The maximum distance of a point to a polynomial so that it counts as a
     * supporter.
     */
    Meter maxDistance;

    /**
     * The horizontal distance to the last detected polynomial, within lane
     * markings have to lie to be considered for the detection of the next
     * polynomial. The width of the polynomial region of interest is two times
     * this distance.
     */
    Meter interestDistancePoly;

    /**
     * The horizontal distance to the default line, within lane markings have to
     * lie to be considered for the detection of a polynomial. The width of the
     * default region of interest is two times this distance.
     */
    Meter interestDistanceDefault;

    /**
     * The minimal x of the ROIs. Points with smaller x-Values are not
     * used in RANSAC.
     */
    Meter minXRoi;

    /**
     * The maximal x of default ROIs. Points with bigger x-Values are not used.
     */
    Meter maxXDefaultRoi;

    /**
     * The maximal x of the polynomial ROIs. Points with bigger x-Values are not
     * used.
     */
    Meter maxXPolyRoi;

    /**
     * The minimal proportion of supporters of all points within a ROI.
     * Polynomials with lower proportions are discarded.
     */
    double proportionThreshould;

    /**
     * Number of RANSAC iterations
     */
    int iterationsRansac;

    /**
     * flags to determine if a valid polynomial was detected in the last frame
     * and therefore the polynomial ROI should be used or if no polynomial could
     * be detected and the default ROI is used.
     */
    bool polyDetectedLeft;
    bool polyDetectedCenter;
    bool polyDetectedRight;

    /**
     * pairs for saving the best lane polynomials produced during RANSAC
     *
     * first : current best NewtonPolynomial
     * second: proportion of supporters of used lane marking points (quality)
     */
    std::pair<NewtonPolynomial, double> bestPolyLeft;
    std::pair<NewtonPolynomial, double> bestPolyCenter;
    std::pair<NewtonPolynomial, double> bestPolyRight;

    /**
     * Lists containing the lane marking points selected for detecting the lane
     * polynomials during RANSAC
     */
    std::vector<Point<Meter>> laneMarkingsLeft;
    std::vector<Point<Meter>> laneMarkingsCenter;
    std::vector<Point<Meter>> laneMarkingsRight;

    /**
     * The lane marking polynomials detected in the current picture.
     */
    NewtonPolynomial polyLeft;
    NewtonPolynomial polyCenter;
    NewtonPolynomial polyRight;

    /**
     * Newton interpolation data points selected for the best polynomial
     */
    std::vector<Point<Meter>> pointsLeft;
    std::vector<Point<Meter>> pointsCenter;
    std::vector<Point<Meter>> pointsRight;

    /**
     * Vectors containing the supporters of the best polynomial
     */
    std::vector<Point<Meter>> supportersLeft;
    std::vector<Point<Meter>> supportersCenter;
    std::vector<Point<Meter>> supportersRight;

    /**
     * The polynomials detected on the previous picture
     */
    NewtonPolynomial prevPolyLeft;
    NewtonPolynomial prevPolyCenter;
    NewtonPolynomial prevPolyRight;

    /**
     * The polynomial representing the center of the right lane
     */
    NewtonPolynomial lanePoly;

    void buildLaneMarkingsLists(const std::vector<Point<Meter>>&);

    Meter horizDistanceToDefaultLine(ePosition&, Point<Meter>&);

    Meter horizDistanceToPolynomial(NewtonPolynomial&, Point<Meter>&);

    Meter horizDistance(Point<Meter>&, Point<Meter>&);

    double gradient(double, std::vector<Point<Meter>>&,
            std::vector<double>);

    double intersection(Point<double>&, double&, std::vector<Point<Meter>>&,
            std::vector<double>&);

    double nextGradient(double, NewtonPolynomial&,
            std::vector<Point<Meter>>&, std::vector<Point<Meter>>&,
            std::vector<double>, std::vector<double>, double);

    bool gradientsSimilar(double&, double&);

    ePosition maxProportion();

    void createLanePoly(ePosition);

    void detectLane(double);

    void ransac();

    bool ransacInternal(ePosition, std::vector<Point<Meter>>&,
            std::pair<NewtonPolynomial, double>&, NewtonPolynomial&,
            std::vector<Point<Meter>>&, NewtonPolynomial&, std::vector<Point<Meter>>&);

    void drawDefaultLines(std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>>,
            int, int, int);

    void drawDefaultRois(std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>>,
            int, int, int);

    void drawPoly(std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>>,
            NewtonPolynomial&, int, int, int);

    void drawPolyRoi(std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>>,
            NewtonPolynomial&, int, int, int);

    std::vector<double> produceXCoordinates(Meter);

    std::vector<double> getPolyYCoordinates(std::vector<double>,
            NewtonPolynomial&);

    void drawSupporters(std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>>,
            std::vector<Point<Meter>>, int, int, int);

    void drawLaneMarkings(std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>>,
            std::vector<Point<Meter>>, int, int, int);

    void drawPoints(std::shared_ptr<DebuggingOption<DRAWING_RELATIVE>>,
            std::vector<Point<Meter>>, int, int, int);

    void writeProportions();

    bool polyValid(ePosition, NewtonPolynomial, NewtonPolynomial);

    bool isInDefaultRoi(ePosition, Point<Meter>&);

    bool isInPolyRoi(NewtonPolynomial&, Point<Meter>&);
};

#endif /* SRC_MODULES_COGNITION_VISION_LANEDETECTOR_H_ */
