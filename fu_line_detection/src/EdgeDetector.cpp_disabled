/*
 * EdgeDetector.cpp
 *
 *  Created on: Jan 10, 2013
 *      Author: lutz, Jannis
 */

#include "EdgeDetector.h"

#include "services.h"
#include "management/config/config.h"

#include "modules/cognition/cognition.h"

#include <string>

#include <math.h>


// use the following to actually activate the module
REGISTER_MODULE(Cognition, EdgeDetector, true, "Detect the edges on the ground")

namespace {
	auto cfgSection = ConfigRegistry::getSection("camera.featureextraction.edge");

	auto cfgFrontDistance = cfgSection->registerOption<int>("scanline.front.distance",  3, "distances between scanlines (front) in cm");
	auto cfgFrontCount    = cfgSection->registerOption<int>("scanline.front.cnt",  100, "count of scanlines (front)");

	auto cfgGradientThresh = cfgSection->registerOption<int>("gradientthreshold",  10, "threshold used to identify gradients marking edges");
	auto cfgNonMaxSupWidth = cfgSection->registerOption<int>("nonmaxsupwidth",  10, "width used for non-max-suppression");

	//debugs
	auto dbgScanlinesFront  = REGISTER_DEBUG("cognition.featureextraction.edge.scanlines.front", DRAWING_CAMERA, "???" );
	auto dbgEdgeCandidatesFront = REGISTER_DEBUG("cognition.featureextraction.edge.edgeCandidates.front", DRAWING_CAMERA, "???");
	auto dbgEdgeCandidatesFrontRel  = REGISTER_DEBUG("cognition.featureextraction.edge.edgeCandidates.frontRel", DRAWING_RELATIVE, "???");

}


//const static int g_prewitKernel1D[] = {-1, -1, -1, 0, 1, 1, 1};
//const static int g_prewitKernel1DWidth = 7;

// try kernel width 5 for now
const static int g_kernel1DWidth = 5;

EdgeDetector::EdgeDetector() :

		initializeScanlines(true),
		scanlinesFront(),
{
}

EdgeDetector::~EdgeDetector()
{
	services.getEvents().unregisterForEvent(EVT_CONFIGURATION_LOADED, this);
}

void EdgeDetector::init()
{
	services.getEvents().registerForEvent(EVT_CONFIGURATION_LOADED, this);
	eventCallback(EVT_CONFIGURATION_LOADED, &services.getConfig());
	// initialize scanlines in next execution
	initializeScanlines = true;
}


void EdgeDetector::eventCallback(EventType eventType, void* data)
{
	m_frontCount    = cfgFrontCount->get();
	m_frontDistance = cfgFrontDistance->get();

	m_gradientThreshold = cfgGradientThresh->get();

	m_nonMaxWidth = cfgNonMaxSupWidth->get();

	// reinitialize scanlines before next execution
	initializeScanlines = true;
}

void EdgeDetector::execute() {
	const CameraROI &roi = getCameraROI();
	const ImageDimensions &imgDim = getImageDimensions();
	Edges &edges = getEdges();

	// do nothing if no image
	// in this case we can't even calculate new scanlines
	// due to possible inconsistencies between roi and future images
	if ((imgDim.imageHeight == 0) || (imgDim.imageWidth == 0)) {
		WARNING("EdgeDetector: uninitialized image, abort execute.")
		return;
	}

	// calculate scanlines and use them in all further executions
	if (initializeScanlines || roi.isDirty) {
		INFO("EdgeDetector: (Re)calculating scanlines.")
		scanlinesFront = getScanlines(Side::FRONT);
		initializeScanlines = false;
	}
/*
	DRAWDEBUG( dbgScanlinesFront, {
		SETCOLORGREEN;
		for (auto scanline : scanlinesFront) {
			for (auto segment : scanline) {
				LINE(
					segment.getStart().getX(),
					segment.getStart().getY(),
					segment.getEnd().getX(),
					segment.getEnd().getY()
				);
			}
		}
	});*/

	// start worker threads to find edges in one region each
	std::future<vector<vector<EdgePoint>>> edgePointsFront = std::async(
			std::launch::async,
			&EdgeDetector::scanSide,
			this,
			Side::FRONT,
			scanlinesFront
		);


	vector<vector<EdgePoint>> front(std::move(edgePointsFront.get()));
/*
	DRAWDEBUG( dbgEdgeCandidatesFront, {
			for (auto scanline : front) {
				for (auto edgePoint : scanline) {
					if (edgePoint.isPositive()) { SETCOLORGREEN; }
					else { SETCOLORRED; }
					auto pos = edgePoint.getImgPos();
					RECTANGLEFILLED(pos.getX(), pos.getY(), 2 , 2)
				}
			}
	});

	DRAWDEBUG( dbgEdgeCandidatesFrontRel, {
			for (auto scanline : front) {
				for (auto edgePoint : scanline) {
					if (edgePoint.isPositive()) { SETCOLORGREEN; }
					else { SETCOLORRED; }
					auto pos = edgePoint.getRelPos();
					RECTANGLEFILLED(Centimeter(pos.getX()).value(), Centimeter(pos.getY()).value(), 3 , 3)
				}
			}
	});*/

	edges.setEdgeListFront(std::move(front));
	return;
}

//TODO: Jannis: add necessary margins for kernel

/**
 * Compute scanlines. Each may consist of multiple segments, split at regions
 * that should not be inspected by the kernel.
 * @param side
 * @return vector of segments of scanlines, walk these segments with the kernel
 */
vector<vector<LineSegment<int>>> EdgeDetector::getScanlines(/*SIDE*/) {
	vector<vector<LineSegment<int>>> scanlines;
	const CameraROI roi = getCameraROI();
	int distance = 1;
	int count = 0;
	int offsetStart = 0;
	int sideWidth = 0;
	// select distance between scanlines, count,
	// pick right offset and calculate width, all w.r.t. side
	// remember, left and right are mirrored
	
	distance = m_frontDistance;
	count = m_frontCount;
	offsetStart = roi.getCenter().getX();
	// think about kernel height
	sideWidth = offsetStart - roi.getImageBox().getTopleft().getX() -1;
	
	int scanlineStart = roi.getImageBox().getTopleft().getY();
	int scanlineEnd = roi.getImageBox().getBottomright().getY();


	int offset;
	int segmentStart = -1;
	vector<LineSegment<int>> scanline;
	for (int i = 0; (i/distance) < count && i <= sideWidth; i += distance) {
		scanline = vector<LineSegment<int>>();
		// walk relative to starting point, direction according to side
		offset = offsetStart - i;
		
		// walk along line
		for (int j = scanlineStart; j <= scanlineEnd; j ++) {
			bool isInside = roi.isInside(Point<int>(offset, j));
			
			// start new scanline segment
			if (isInside && j < scanlineEnd) {
				if (segmentStart == -1) segmentStart = j;
			// found end of scanline segment, reset start
			} else if (segmentStart != -1) {				
				scanline.push_back(
						LineSegment<int>(
								Point<int>(offset, segmentStart),
								Point<int>(offset, j-1)
							)
						);
				
				segmentStart = -1;
			}
		}
		// push segments found
		if (scanline.size()) {
			scanlines.push_back(scanline);
		}
	}
	return scanlines;
}

/**
 * Walk with prewitt/sobel kernel along all scanlines of one side.
 * @param side
 * @return All edgePoints on side, sorted by scanlines.
 */
vector<vector<EdgePoint>> EdgeDetector::scanSide(Side side, vector<vector<LineSegment<int>>> scanlines) {
	vector<vector<EdgePoint>> sideEdgePoints;
	const Image &image = getImage();
	const ImageDimensions &imgDim = getImageDimensions();
	const OmnidirectionalCameraMatrix &cameraMatrix = getOmnidirectionalCameraMatrix();

	// scanline length can maximal be image height/width
	int scanlineMaxLength = imgDim.imageHeight;
	
	// store kernel results on current scanline in here
	vector<int> scanlineVals(scanlineMaxLength, 0);

	// walk over all scanlines
	for (auto scanline : scanlines) {
		// set all brightness values on scanline to 0;
		std::fill(scanlineVals.begin(), scanlineVals.end(), 0);
		int offset = 0;
		if (scanline.size()) {
			offset = scanline.front().getStart().getX();			
		}
		// scanline consisting of multiple segments
		// walk over each but store kernel results for whole scanline
		for (auto segment : scanline) {			
			int start = segment.getStart().getY();
			int end = segment.getEnd().getY();
			
			// walk along segment
			for (int i = start; i < end - g_kernel1DWidth; i++) {
				int sum = 0;
				// height of kernel (now 3)
//				for (int j = -1; j < 2; j++) {
//					for (int k = 0; k < g_prewitKernel1DWidth; k++) {
//						int brightness = 0;
//						if (side == Side::FRONT || side == Side::BACK) {
//							brightness = image.getPixelBrightness(offset + j, i + k);
//						}
//						else {
//							brightness = image.getPixelBrightness(i + k, offset + j);
//						}
//						if (brightness != 0) {
//							sum += g_prewitKernel1D[k] * brightness;
//						}
//					}

				/*
				 * Sorry, I'm gonna do loop unrolling. It increases the kernel performance by
				 * approximately 3 ms :). Of course you will revert this if you prefer clear
				 * code over runntime.
				 * Kernel width stays 7, height 3.
				 */
				if (side == Side::FRONT || side == Side::BACK) {
					// comment in for kernel width 7
//					sum -= image.getPixelBrightness(offset -1, i);
//					sum -= image.getPixelBrightness(offset -1, i+1);
//					sum -= image.getPixelBrightness(offset -1, i+2);
//					// kernel is 0
//					sum += image.getPixelBrightness(offset -1, i+4);
//					sum += image.getPixelBrightness(offset -1, i+5);
//					sum += image.getPixelBrightness(offset -1, i+6);
//
//					sum -= image.getPixelBrightness(offset, i);
//					sum -= image.getPixelBrightness(offset, i+1);
//					sum -= image.getPixelBrightness(offset, i+2);
//					// kernel is 0
//					sum += image.getPixelBrightness(offset, i+4);
//					sum += image.getPixelBrightness(offset, i+5);
//					sum += image.getPixelBrightness(offset, i+6);
//
//					sum -= image.getPixelBrightness(offset+1, i);
//					sum -= image.getPixelBrightness(offset+1, i+1);
//					sum -= image.getPixelBrightness(offset+1, i+2);
//					// kernel is 0
//					sum += image.getPixelBrightness(offset+1, i+4);
//					sum += image.getPixelBrightness(offset+1, i+5);
//					sum += image.getPixelBrightness(offset+1, i+6);

					// use kernel width 5 and try sobel kernel
					sum -= image.getPixelBrightness(offset -1, i);
					sum -= image.getPixelBrightness(offset -1, i+1);
					// kernel is 0
					sum += image.getPixelBrightness(offset -1, i+3);
					sum += image.getPixelBrightness(offset -1, i+4);

					sum -= 2*image.getPixelBrightness(offset, i);
					sum -= 2*image.getPixelBrightness(offset, i+1);
					// kernel is 0
					sum += 2*image.getPixelBrightness(offset, i+3);
					sum += 2*image.getPixelBrightness(offset, i+4);

					sum -= image.getPixelBrightness(offset +1, i);
					sum -= image.getPixelBrightness(offset +1, i+1);
					// kernel is 0
					sum += image.getPixelBrightness(offset +1, i+3);
					sum += image.getPixelBrightness(offset +1, i+4);
				}
				else {
					// comment in for kernel width 7
//					sum -= image.getPixelBrightness(i, offset-1);
//					sum -= image.getPixelBrightness(i+1, offset-1);
//					sum -= image.getPixelBrightness(i+2, offset-1);
//					// kernel is 0
//					sum += image.getPixelBrightness(i+4, offset-1);
//					sum += image.getPixelBrightness(i+5, offset-1);
//					sum += image.getPixelBrightness(i+6, offset-1);
//
//					sum -= image.getPixelBrightness(i, offset);
//					sum -= image.getPixelBrightness(i+1, offset);
//					sum -= image.getPixelBrightness(i+2, offset);
//					// kernel is 0
//					sum += image.getPixelBrightness(i+4, offset);
//					sum += image.getPixelBrightness(i+5, offset);
//					sum += image.getPixelBrightness(i+6, offset);
//
//					sum -= image.getPixelBrightness(i, offset+1);
//					sum -= image.getPixelBrightness(i+1, offset+1);
//					sum -= image.getPixelBrightness(i+2, offset+1);
//					// kernel is 0
//					sum += image.getPixelBrightness(i+4, offset+1);
//					sum += image.getPixelBrightness(i+5, offset+1);
//					sum += image.getPixelBrightness(i+6, offset+1);

					// use kernel width 5 and try sobel kernel
					sum -= image.getPixelBrightness(i, offset-1);
					sum -= image.getPixelBrightness(i+1, offset-1);
					// kernel is 0
					sum += image.getPixelBrightness(i+2, offset-1);
					sum += image.getPixelBrightness(i+4, offset-1);

					sum -= 2*image.getPixelBrightness(i, offset);
					sum -= 2*image.getPixelBrightness(i+1, offset);
					// kernel is 0
					sum += 2*image.getPixelBrightness(i+2, offset);
					sum += 2*image.getPixelBrightness(i+4, offset);

					sum -= image.getPixelBrightness(i, offset+1);
					sum -= image.getPixelBrightness(i+1, offset+1);
					// kernel is 0
					sum += image.getPixelBrightness(i+2, offset+1);
					sum += image.getPixelBrightness(i+4, offset+1);
				}
				// +4 because of sobel weighting
				sum = sum / (3 * g_kernel1DWidth + 4);
				if (std::abs(sum) > m_gradientThreshold) {
					// set scanlineVals at center of kernel
					scanlineVals[i + g_kernel1DWidth/2] = sum;
				}
			}
		}

		// after walking over all segments of one scanline
		// do non-max-suppression
		// for both minima and maxima at same time
		// TODO: Jannis: find dryer way
		int indexOfLastMaximum = 0;
		int valueOfLastMaximum = 0;
		int indexOfLastMinimum = 0;
		int valueOfLastMinimum = 0;
		for (int i = 1; i < scanlineMaxLength -1; i++) {
			// check if maximum
			if (scanlineVals[i] > 0) {
				if (scanlineVals[i] < scanlineVals[i-1] or scanlineVals[i] < scanlineVals[i+1]) {
					scanlineVals[i] = 0;
				}
				else {
					// this pixel can just survive if the next maximum is not too close
					if (i - indexOfLastMaximum > m_nonMaxWidth) {
						// this is a new maximum
						indexOfLastMaximum = i;
						valueOfLastMaximum = scanlineVals[i];
					}
					else {
						if (valueOfLastMaximum < scanlineVals[i]) {
							// this is a new maximum
							// drop the old maximum
							scanlineVals[indexOfLastMaximum] = 0;
							indexOfLastMaximum = i;
							valueOfLastMaximum = scanlineVals[i];
						}
						else {
							scanlineVals[i] = 0;
						}
					}
				}
			}
			// check if minimum
			if (scanlineVals[i] < 0) {
				if (scanlineVals[i] > scanlineVals[i-1] or scanlineVals[i] > scanlineVals[i+1]) {
					scanlineVals[i] = 0;
				}
				else {
					// this pixel can just survive if the next minimum is not too close
					if (i - indexOfLastMinimum > m_nonMaxWidth) {
						// this is a new minimum
						indexOfLastMinimum = i;
						valueOfLastMinimum = scanlineVals[i];
					}
					else {
						if (valueOfLastMinimum > scanlineVals[i]) {
							// this is a new maximum
							// drop the old maximum
							scanlineVals[indexOfLastMinimum] = 0;
							indexOfLastMinimum = i;
							valueOfLastMinimum = scanlineVals[i];
						}
						else {
							scanlineVals[i] = 0;
						}
					}
				}
			}
		}
		// collect all the edgePoints for scanline
		vector<EdgePoint> scanlineEdgePoints;
		for (int i = 0; i < static_cast<int>(scanlineVals.size()); i++) {
			if (scanlineVals[i] != 0) {
				Point<int> imgPos = {offset, i};
				
				Point<Meter> relPos = cameraMatrix.transformToLocalCoordinates(imgPos);
				scanlineEdgePoints.push_back(EdgePoint(imgPos, relPos, scanlineVals[i]));
			}
		}
		sideEdgePoints.push_back(std::move(scanlineEdgePoints));
	}
	// after walking along all scanlines
	// return edgePoints for whole side
	return sideEdgePoints;
}
